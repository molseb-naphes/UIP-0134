# UIP-0134
|UIP|Title|Description|Author|Status|Type|Category|Created  
|---|-----|-----------|------|------|----|---------|-------|
|0134|Post Quantum urbitOS|ML-KEM & ML-DSA|~molseb-naphes|Draft|OS upgrade|Standard Track|~2025-08-01 
---

## Abstract

This Urbit Improvement Proposal (UIP) outlines the integration of NIST-standardized post-quantum (PQ) cryptographic algorithms into urbitOS to ensure long-term security against quantum computing threats. The proposal introduces ML-KEM (FIPS 203) for key encapsulation and ML-DSA (Dilithium) for digital signatures, implementing a hybrid cryptographic approach that maintains backward compatibility while providing quantum resistance.

## Motivation

### The Quantum Threat Timeline

Quantum computers pose an existential threat to current public-key cryptography. Recent developments indicate that cryptographically relevant quantum computers may emerge within the next 10-20 years. Urbit's commitment to being a "100-year computer" necessitates proactive quantum resistance measures. Both Google and Microsoft are implementing Post Quantum (PQ) in 2025... that is a strong signal from the incumbents. 

### Current Cryptographic Vulnerabilities

Urbit's existing cryptographic infrastructure relies on:
- **ECDH** (Elliptic Curve Diffie-Hellman) for key exchange
- **ECDSA** (Elliptic Curve Digital Signature Algorithm) for authentication
- **AES** for symmetric encryption (quantum-resistant)

Both ECDH and ECDSA are vulnerable to Shor's algorithm running on a sufficiently large quantum computer. While AES is 'resistant' (

### Strategic Importance

1. **Future-Proofing**: Ensures Urbit remains secure as quantum computing advances
2. **Network Integrity**: Protects the peer-to-peer communication foundation
3. **Identity Security**: Safeguards ship identities and the Azimuth PKI
4. **Compliance Readiness**: Aligns with emerging quantum-safe standards

## Detailed Design

### Cryptographic Algorithm Selection

#### ML-KEM (Module-Lattice-Based Key Encapsulation Mechanism)
- **Standard**: FIPS 203
- **Security Level**: ML-KEM-768 (NIST Level 3 equivalent)
- **Performance**: Optimized for network protocols
- **Key Sizes**: Public key 1,184 bytes, Ciphertext 1,088 bytes

#### ML-DSA (Module-Lattice-Based Digital Signature Algorithm)
- **Standard**: FIPS 204 (Dilithium)
- **Security Level**: ML-DSA-65 (NIST Level 3 equivalent)  
- **Performance**: Suitable for authentication protocols
- **Signature Size**: ~3,309 bytes (variable)

### Architecture Integration Points

#### 1. Vere Runtime (C Implementation)
<detail>
  
```c
/**
 * Post-Quantum Cryptography Implementation for Vere Runtime
 * ML-KEM (FIPS 203) and ML-DSA (FIPS 204) integration
 */

#include "all.h"
#include <oqs/oqs.h>  // Open Quantum Safe library

// ML-KEM-768 parameters (NIST Level 3)
#define MLKEM_PUBLICKEY_BYTES   1184
#define MLKEM_SECRETKEY_BYTES   2400  
#define MLKEM_CIPHERTEXT_BYTES  1088
#define MLKEM_SHARED_SECRET_BYTES 32

// ML-DSA-65 parameters (NIST Level 3)  
#define MLDSA_PUBLICKEY_BYTES   1952
#define MLDSA_SECRETKEY_BYTES   4000
#define MLDSA_SIGNATURE_BYTES   3309  // Maximum size

/**
 * ML-KEM key generation
 * Returns: c3_o - c3y on success, c3n on failure
 */
c3_o
u3_mlkem_keygen(c3_y* pub_key, c3_y* sec_key)
{
  if (!pub_key || !sec_key) {
    return c3n;
  }

  OQS_KEM* kem = OQS_KEM_new(OQS_KEM_alg_ml_kem_768);
  if (!kem) {
    u3l_log("mlkem: failed to initialize ML-KEM-768\n");
    return c3n;
  }

  OQS_STATUS status = OQS_KEM_keypair(kem, pub_key, sec_key);
  
  OQS_KEM_free(kem);
  
  if (status != OQS_SUCCESS) {
    u3l_log("mlkem: key generation failed\n");
    return c3n;
  }

  return c3y;
}

/**
 * ML-KEM encapsulation
 * Returns: c3_o - c3y on success, c3n on failure
 */
c3_o
u3_mlkem_encaps(const c3_y* pub_key, c3_y* cipher, c3_y* shared_secret)
{
  if (!pub_key || !cipher || !shared_secret) {
    return c3n;
  }

  OQS_KEM* kem = OQS_KEM_new(OQS_KEM_alg_ml_kem_768);
  if (!kem) {
    u3l_log("mlkem: failed to initialize ML-KEM-768 for encaps\n");
    return c3n;
  }

  OQS_STATUS status = OQS_KEM_encaps(kem, cipher, shared_secret, pub_key);
  
  OQS_KEM_free(kem);
  
  if (status != OQS_SUCCESS) {
    u3l_log("mlkem: encapsulation failed\n");
    return c3n;
  }

  return c3y;
}

/**
 * ML-KEM decapsulation
 * Returns: c3_o - c3y on success, c3n on failure
 */
c3_o
u3_mlkem_decaps(const c3_y* sec_key, const c3_y* cipher, c3_y* shared_secret)
{
  if (!sec_key || !cipher || !shared_secret) {
    return c3n;
  }

  OQS_KEM* kem = OQS_KEM_new(OQS_KEM_alg_ml_kem_768);
  if (!kem) {
    u3l_log("mlkem: failed to initialize ML-KEM-768 for decaps\n");
    return c3n;
  }

  OQS_STATUS status = OQS_KEM_decaps(kem, shared_secret, cipher, sec_key);
  
  OQS_KEM_free(kem);
  
  if (status != OQS_SUCCESS) {
    u3l_log("mlkem: decapsulation failed\n");
    return c3n;
  }

  return c3y;
}

/**
 * ML-DSA key generation
 * Returns: c3_o - c3y on success, c3n on failure
 */  
c3_o
u3_mldsa_keygen(c3_y* pub_key, c3_y* sec_key)
{
  if (!pub_key || !sec_key) {
    return c3n;
  }

  OQS_SIG* sig = OQS_SIG_new(OQS_SIG_alg_ml_dsa_65);
  if (!sig) {
    u3l_log("mldsa: failed to initialize ML-DSA-65\n");
    return c3n;
  }

  OQS_STATUS status = OQS_SIG_keypair(sig, pub_key, sec_key);
  
  OQS_SIG_free(sig);
  
  if (status != OQS_SUCCESS) {
    u3l_log("mldsa: key generation failed\n");
    return c3n;
  }

  return c3y;
}

/**
 * ML-DSA signature generation
 * Returns: c3_o - c3y on success, c3n on failure
 * sig_len: input/output parameter for signature length
 */
c3_o
u3_mldsa_sign(const c3_y* sec_key, const c3_y* message, c3_w msg_len,
              c3_y* signature, c3_w* sig_len)
{
  if (!sec_key || !message || !signature || !sig_len) {
    return c3n;
  }

  OQS_SIG* sig = OQS_SIG_new(OQS_SIG_alg_ml_dsa_65);
  if (!sig) {
    u3l_log("mldsa: failed to initialize ML-DSA-65 for signing\n");
    return c3n;
  }

  size_t signature_len = *sig_len;
  OQS_STATUS status = OQS_SIG_sign(sig, signature, &signature_len,
                                   message, msg_len, sec_key);
  
  *sig_len = (c3_w)signature_len;
  OQS_SIG_free(sig);
  
  if (status != OQS_SUCCESS) {
    u3l_log("mldsa: signing failed\n");
    return c3n;
  }

  return c3y;
}

/**
 * ML-DSA signature verification
 * Returns: c3_o - c3y if valid, c3n if invalid or error
 */
c3_o
u3_mldsa_verify(const c3_y* pub_key, const c3_y* message, c3_w msg_len,
                const c3_y* signature, c3_w sig_len)
{
  if (!pub_key || !message || !signature) {
    return c3n;
  }

  OQS_SIG* sig = OQS_SIG_new(OQS_SIG_alg_ml_dsa_65);
  if (!sig) {
    u3l_log("mldsa: failed to initialize ML-DSA-65 for verification\n");
    return c3n;
  }

  OQS_STATUS status = OQS_SIG_verify(sig, message, msg_len,
                                     signature, sig_len, pub_key);
  
  OQS_SIG_free(sig);
  
  if (status != OQS_SUCCESS) {
    return c3n;  // Invalid signature or error
  }

  return c3y;  // Valid signature
}

/**
 * Hoon interface for ML-KEM key generation
 * Returns: cell [pub sec] or ~ on failure
 */
u3_noun
u3we_mlkem_keygen(u3_noun cor)
{
  c3_y pub_key[MLKEM_PUBLICKEY_BYTES];
  c3_y sec_key[MLKEM_SECRETKEY_BYTES];
  
  c3_o res = u3_mlkem_keygen(pub_key, sec_key);
  
  if (c3n == res) {
    return u3_none;  // Return ~ on failure
  }
  
  u3_noun pub = u3i_bytes(MLKEM_PUBLICKEY_BYTES, pub_key);
  u3_noun sec = u3i_bytes(MLKEM_SECRETKEY_BYTES, sec_key); 
  
  return u3nc(pub, sec);  // Return [pub sec]
}

/**
 * Hoon interface for ML-KEM encapsulation
 * Takes: pub-key atom
 * Returns: cell [shared-secret ciphertext] or ~ on failure
 */
u3_noun
u3we_mlkem_encaps(u3_noun cor)
{
  u3_noun pub = u3x_at(u3x_sam, cor);
  
  if (u3_none == pub) {
    return u3_none;
  }
  
  c3_w pub_len = u3r_met(3, pub);  // Get byte length
  if (pub_len != MLKEM_PUBLICKEY_BYTES) {
    return u3_none;  // Wrong key size
  }
  
  c3_y pub_key[MLKEM_PUBLICKEY_BYTES];
  c3_y cipher[MLKEM_CIPHERTEXT_BYTES];
  c3_y shared_secret[MLKEM_SHARED_SECRET_BYTES];
  
  u3r_bytes(0, pub_len, pub_key, pub);
  
  c3_o res = u3_mlkem_encaps(pub_key, cipher, shared_secret);
  
  if (c3n == res) {
    return u3_none;
  }
  
  u3_noun key = u3i_bytes(MLKEM_SHARED_SECRET_BYTES, shared_secret);
  u3_noun cip = u3i_bytes(MLKEM_CIPHERTEXT_BYTES, cipher);
  
  return u3nc(key, cip);  // Return [key cipher]
}

/**
 * Hoon interface for ML-KEM decapsulation  
 * Takes: cell [sec-key ciphertext]
 * Returns: shared-secret atom or ~ on failure
 */
u3_noun
u3we_mlkem_decaps(u3_noun cor)
{
  u3_noun sam = u3x_at(u3x_sam, cor);
  u3_noun sec = u3h(sam);
  u3_noun cip = u3t(sam);
  
  if (u3_none == sec || u3_none == cip) {
    return u3_none;
  }
  
  c3_w sec_len = u3r_met(3, sec);
  c3_w cip_len = u3r_met(3, cip);
  
  if (sec_len != MLKEM_SECRETKEY_BYTES || cip_len != MLKEM_CIPHERTEXT_BYTES) {
    return u3_none;  // Wrong sizes
  }
  
  c3_y sec_key[MLKEM_SECRETKEY_BYTES];
  c3_y cipher[MLKEM_CIPHERTEXT_BYTES]; 
  c3_y shared_secret[MLKEM_SHARED_SECRET_BYTES];
  
  u3r_bytes(0, sec_len, sec_key, sec);
  u3r_bytes(0, cip_len, cipher, cip);
  
  c3_o res = u3_mlkem_decaps(sec_key, cipher, shared_secret);
  
  if (c3n == res) {
    return u3_none;
  }
  
  return u3i_bytes(MLKEM_SHARED_SECRET_BYTES, shared_secret);
}

/**
 * Hoon interface for ML-DSA key generation
 * Returns: cell [pub sec] or ~ on failure  
 */
u3_noun
u3we_mldsa_keygen(u3_noun cor)
{
  c3_y pub_key[MLDSA_PUBLICKEY_BYTES];
  c3_y sec_key[MLDSA_SECRETKEY_BYTES];
  
  c3_o res = u3_mldsa_keygen(pub_key, sec_key);
  
  if (c3n == res) {
    return u3_none;
  }
  
  u3_noun pub = u3i_bytes(MLDSA_PUBLICKEY_BYTES, pub_key);
  u3_noun sec = u3i_bytes(MLDSA_SECRETKEY_BYTES, sec_key);
  
  return u3nc(pub, sec);
}

/**
 * Hoon interface for ML-DSA signing
 * Takes: cell [sec-key message]  
 * Returns: signature atom or ~ on failure
 */
u3_noun  
u3we_mldsa_sign(u3_noun cor)
{
  u3_noun sam = u3x_at(u3x_sam, cor);
  u3_noun sec = u3h(sam);
  u3_noun msg = u3t(sam);
  
  if (u3_none == sec || u3_none == msg) {
    return u3_none;
  }
  
  c3_w sec_len = u3r_met(3, sec);
  c3_w msg_len = u3r_met(3, msg);
  
  if (sec_len != MLDSA_SECRETKEY_BYTES) {
    return u3_none;  // Wrong key size
  }
  
  c3_y sec_key[MLDSA_SECRETKEY_BYTES];
  c3_y* message = c3_malloc(msg_len);
  c3_y signature[MLDSA_SIGNATURE_BYTES];
  c3_w sig_len = MLDSA_SIGNATURE_BYTES;
  
  if (!message) {
    return u3_none;  // Memory allocation failed
  }
  
  u3r_bytes(0, sec_len, sec_key, sec);
  u3r_bytes(0, msg_len, message, msg);
  
  c3_o res = u3_mldsa_sign(sec_key, message, msg_len, signature, &sig_len);
  
  c3_free(message);
  
  if (c3n == res) {
    return u3_none;
  }
  
  return u3i_bytes(sig_len, signature);
}

/**
 * Hoon interface for ML-DSA verification
 * Takes: cell [pub-key message signature]
 * Returns: %.y if valid, %.n if invalid
 */
u3_noun
u3we_mldsa_verify(u3_noun cor)
{
  u3_noun sam = u3x_at(u3x_sam, cor);
  u3_noun pub = u3h(sam);
  u3_noun msg = u3h(u3t(sam));
  u3_noun sig = u3t(u3t(sam));
  
  if (u3_none == pub || u3_none == msg || u3_none == sig) {
    return c3n;  // Return %.n for invalid inputs
  }
  
  c3_w pub_len = u3r_met(3, pub);
  c3_w msg_len = u3r_met(3, msg);
  c3_w sig_len = u3r_met(3, sig);
  
  if (pub_len != MLDSA_PUBLICKEY_BYTES) {
    return c3n;  // Wrong key size
  }
  
  c3_y pub_key[MLDSA_PUBLICKEY_BYTES];
  c3_y* message = c3_malloc(msg_len);
  c3_y* signature = c3_malloc(sig_len);
  
  if (!message || !signature) {
    if (message) c3_free(message);
    if (signature) c3_free(signature);
    return c3n;  // Memory allocation failed
  }
  
  u3r_bytes(0, pub_len, pub_key, pub);
  u3r_bytes(0, msg_len, message, msg);
  u3r_bytes(0, sig_len, signature, sig);
  
  c3_o res = u3_mldsa_verify(pub_key, message, msg_len, signature, sig_len);
  
  c3_free(message);
  c3_free(signature);
  
  return res;  // Return c3y (%.y) or c3n (%.n)
}
```
</detail>

**Dependencies**:
- liboqs (Open Quantum Safe library)
- Integration with existing crypto in `c/ames.c`

#### 2. Arvo Kernel (Hoon Implementation)
<detail>
  
```hoon
::  Post-Quantum Cryptography Library for Urbit
::  ML-KEM (FIPS 203) and ML-DSA (Dilithium) implementations
::
::  Usage examples:
::    =mlkem-keys (keygen:mlkem)
::    =encap-result (encaps:mlkem pub.mlkem-keys)
::    =shared-key (need (decaps:mlkem [sec.mlkem-keys cipher.encap-result]))
::    =mldsa-keys (keygen:mldsa)
::    =signature (sign:mldsa [sec.mldsa-keys 0xdead.beef])
::    =is-valid (verify:mldsa [pub.mldsa-keys 0xdead.beef signature])
::
|%
::  Common types for post-quantum cryptography
++  keypair  [pub=@ sec=@)
++  capsule  [key=@ cipher=@]
::
::  ML-KEM (Module-Lattice-Based Key Encapsulation Mechanism)
::  FIPS 203 standard implementation
++  mlkem
  |%
  ::  Generate ML-KEM keypair
  ::  Returns: [pub=@ sec=@] where pub is public key, sec is secret key  
  ++  keygen
    ^-  keypair
    ::  TODO: Replace with actual ML-KEM-768 keygen via Vere runtime
    ::  This should call into C implementation via ++en-mlkem-keygen
    [pub=0x1234.5678.9abc.def0 sec=0xfeed.face.dead.beef]
  ::
  ::  Encapsulate shared secret using public key
  ::  Takes: pub=@ (public key)
  ::  Returns: [key=@ cipher=@] where key is shared secret, cipher is encapsulation
  ++  encaps
    |=  pub=@
    ^-  capsule
    ::  TODO: Replace with actual ML-KEM encapsulation
    ::  This should call into C implementation  
    ?:  =(pub 0)
      [key=0 cipher=0]  :: Handle invalid pub key
    [key=0xcafe.babe cipher=0xface.feed]
  ::
  ::  Decapsulate shared secret using secret key and ciphertext
  ::  Takes: [sec=@ cipher=@] (secret key and encapsulation)
  ::  Returns: (unit @) - ~ if decapsulation fails, [~ shared-secret] if succeeds
  ++  decaps
    |=  [sec=@ cipher=@]
    ^-  (unit @)
    ::  TODO: Replace with actual ML-KEM decapsulation
    ::  This should call into C implementation
    ?:  |((=(sec 0) (=(cipher 0)))
      ~  :: Return ~ (null) for invalid inputs
    `0xcafe.babe  :: Return shared secret wrapped in unit
  --
::
::  ML-DSA (Module-Lattice-Based Digital Signature Algorithm) 
::  FIPS 204 standard (Dilithium) implementation
++  mldsa
  |%
  ::  Generate ML-DSA keypair
  ::  Returns: [pub=@ sec=@] where pub is public key, sec is secret key
  ++  keygen
    ^-  keypair  
    ::  TODO: Replace with actual ML-DSA-65 keygen via Vere runtime
    ::  This should call into C implementation via ++en-mldsa-keygen
    [pub=0xabcd.ef01.2345.6789 sec=0x9876.5432.10fe.dcba]
  ::
  ::  Sign message using secret key
  ::  Takes: [sec=@ msg=@] (secret key and message)
  ::  Returns: @ (signature bytes)  
  ++  sign
    |=  [sec=@ msg=@]
    ^-  @
    ::  TODO: Replace with actual ML-DSA signing
    ::  This should call into C implementation
    ?:  =(sec 0)
      0  :: Return 0 for invalid secret key
    ::  Combine sec and msg in a deterministic way for stub
    (add (mul sec 0x1337) (mul msg 0xcafe))
  ::
  ::  Verify signature using public key
  ::  Takes: [pub=@ msg=@ sig=@] (public key, message, signature)
  ::  Returns: ? (boolean - %.y if valid, %.n if invalid)
  ++  verify
    |=  [pub=@ msg=@ sig=@]
    ^-  ?
    ::  TODO: Replace with actual ML-DSA verification  
    ::  This should call into C implementation
    ?:  |((=(pub 0) (=(sig 0)))
      %.n  :: Return %.n (false) for invalid inputs
    ::  Stub verification - check if signature matches expected pattern
    ::  In real implementation, this would verify the cryptographic signature
    =(sig (add (mul 0x1337.0000 (mod pub 0x1.0000)) (mul msg 0xcafe)))
  --
::
::  Hybrid crypto utilities for transition period
++  hybrid
  |%
  ::  Combine classical ECDH and ML-KEM shared secrets
  ::  Takes: [classical=@ quantum=@] 
  ::  Returns: @ (combined shared secret)
  ++  combine-secrets
    |=  [classical=@ quantum=@]
    ^-  @
    ::  Use XOR combination as specified in hybrid crypto standards
    (mix classical quantum)
  ::
  ::  Dual signature verification (ECDSA + ML-DSA)
  ::  Takes: [ecdsa-pub=@ mldsa-pub=@ msg=@ ecdsa-sig=@ mldsa-sig=@]
  ::  Returns: ? (both signatures must be valid)
  ++  dual-verify
    |=  $:  ecdsa-pub=@
            mldsa-pub=@  
            msg=@
            ecdsa-sig=@
            mldsa-sig=@
        ==
    ^-  ?
    ::  Both classical and post-quantum signatures must verify
    ?&  ::  TODO: Replace with actual ECDSA verification
        (gth ecdsa-pub 0)  :: stub - always true if pub key exists
        (verify:mldsa [mldsa-pub msg mldsa-sig])
    ==
  --
--
```
</detail>


#### 3. Ames Networking Protocol
- **Packet Format Extension**: New header fields for crypto negotiation
- **Handshake Protocol**: Hybrid classical/PQ key exchange
- **Encryption Pipeline**: ML-KEM derived keys with AES

#### 4. Jael Identity Management
- **Key Storage**: Extended to include PQ keypairs
- **Ship Spawning**: Generate both classical and PQ keys
- **Key Rotation**: Automated PQ key lifecycle management

### Migration Strategy

#### Phase 1: Hybrid Implementation (Months 1-6)
- Ships support both classical and PQ crypto
- Backward compatibility maintained
- Gradual network adoption

#### Phase 2: PQ-Preferred (Months 7-12)
- New ships default to PQ crypto
- Classical crypto marked as legacy
- Performance optimizations

#### Phase 3: PQ-Only (Year 2+)
- Classical crypto deprecated
- Full quantum resistance achieved
- Legacy support removal

### Protocol Specifications

#### New Packet Format
```
[version:1][crypto_suite:1][header:32][pq_kem_data:1088][payload:*][pq_signature:3309]
```

#### Crypto Suite Negotiation
```
0x00: Classical only (ECDH + ECDSA)
0x01: Hybrid (ECDH + ML-KEM, ECDSA + ML-DSA)  
0x02: PQ only (ML-KEM + ML-DSA)
0xFF: Reserved for future algorithms
```

#### Key Exchange Protocol
1. **Initiation**: Ship A sends ML-KEM public key + ECDH public key
2. **Response**: Ship B encapsulates secret with both algorithms
3. **Derivation**: Combine classical and PQ shared secrets
4. **Authentication**: Dual signature verification (ECDSA + ML-DSA)

## Performance Considerations

### Computational Overhead
- **ML-KEM**: ~10x slower than ECDH key generation
- **ML-DSA**: ~50x slower than ECDSA signing
- **Mitigation**: Asynchronous crypto operations, key caching

### Network Overhead  
- **Packet Size**: ~4KB increase due to PQ signatures
- **Bandwidth**: 3-4x increase in handshake traffic
- **Mitigation**: Signature compression, protocol optimization

### Memory Requirements
- **Key Storage**: ~3KB per ship for PQ keys vs ~64 bytes classical
- **Mitigation**: Key derivation from seed, optional key pruning

## Security Analysis

### Threat Model
- **Quantum Adversary**: Capable of breaking classical ECDH/ECDSA
- **Classical Adversary**: Still relevant during transition period
- **Network Adversary**: Can intercept and analyze traffic

### Security Properties
- **Confidentiality**: ML-KEM provides quantum-safe key exchange
- **Authenticity**: ML-DSA ensures quantum-safe digital signatures  
- **Forward Secrecy**: Ephemeral keys prevent retroactive decryption
- **Hybrid Security**: Classical+PQ combination provides defense in depth

### Risk Mitigation
- **Algorithm Agility**: Framework supports future algorithm updates
- **Gradual Migration**: Reduces risk of network fragmentation
- **Fallback Mechanisms**: Classical crypto available if PQ fails

## Backwards Compatibility

### Compatibility Matrix
| Ship Version | Classical | Hybrid | PQ-Only |
|--------------|-----------|---------|---------|
| Legacy       | ✓         | ✗       | ✗       |
| Hybrid       | ✓         | ✓       | ✗       |
| PQ-Ready     | ✓         | ✓       | ✓       |

### Migration Path
1. **Ships update** to hybrid-capable runtime
2. **Network negotiation** determines optimal crypto suite
3. **Gradual transition** to PQ-preferred mode
4. **Eventually deprecate** classical-only support

## Testing Strategy

### Unit Testing
- Crypto primitive correctness
- Key generation/validation
- Signature verification
- Interoperability testing

### Integration Testing  
- End-to-end encrypted communication
- Handshake protocol validation
- Performance regression testing
- Memory usage profiling

### Network Testing
- Multi-ship PQ communication
- Mixed classical/PQ networks
- Failure mode testing
- Load testing with PQ overhead

## Alternative Approaches Considered

### Other PQ Algorithms
- **CRYSTALS-Kyber/Dilithium**: Chosen ML-KEM/ML-DSA are standardized versions
- **FALCON**: Smaller signatures but complex implementation
- **SPHINCS+**: Stateless but very large signatures

### Implementation Strategies
- **PQ-Only**: Rejected due to compatibility concerns
- **Classical Fallback**: Rejected due to security implications
- **Hybrid Approach**: Selected for optimal security/compatibility balance

### Operational Impact
- **Bandwidth Increase**: 3-4x during handshakes, minimal during data transfer
- **Compute Overhead**: 10-50x increase in crypto operations
- **Storage Requirements**: ~3KB additional per ship identity

### Long-term Benefits
- **Future-Proofing**: Avoids costly emergency migration later
- **Competitive Advantage**: Early quantum-safe adoption
- **Risk Mitigation**: Protects against quantum cryptanalysis

## Open Questions

1. **Algorithm Parameters**: Optimal security level (Level 1 vs Level 3)?
2. **Implementation Library**: liboqs vs custom implementation?
3. **Key Rotation**: Automatic vs manual PQ key updates?
4. **Compression**: Worth implementing signature compression?
5. **Hybrid KDF**: How to combine classical + PQ shared secrets?

## References

- [FIPS 203: Module-Lattice-Based Key-Encapsulation Mechanism Standard](https://csrc.nist.gov/pubs/fips/203/final)
- [FIPS 204: Module-Lattice-Based Digital Signature Standard](https://csrc.nist.gov/pubs/fips/204/final)  
- [NIST Post-Quantum Cryptography Standardization](https://csrc.nist.gov/projects/post-quantum-cryptography)
- [Open Quantum Safe Project](https://openquantumsafe.org/)
- https://github.com/open-quantum-safe/oqs-provider 
- [Urbit Cryptographic Architecture](https://urbit.org/docs/reference/runtime/cryptography)
- https://cloud.google.com/blog/products/identity-security/announcing-quantum-safe-digital-signatures-in-cloud-kms
- https://techcommunity.microsoft.com/blog/microsoft-security-blog/post-quantum-cryptography-comes-to-windows-insiders-and-linux/4413803

## Acknowledgments

Special thanks to the Urbit core development team, the post-quantum cryptography research community, and NIST for their standardization efforts.

---



